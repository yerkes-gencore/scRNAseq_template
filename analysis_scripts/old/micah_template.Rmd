---
title: "scRNAqc_comparing_inputs.Rmd"
author: "micah"
date: "2023-02-24"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(yaml)
library(tidyverse)
library(Seurat)
library(ggridges)
library(ggpubr)
library(here)
here()
# For parallel implementation
library(foreach)
library(doParallel)
```

# Setup
```{r}
source(here("micah_functions.R"))
config <- yaml::yaml.load_file("scRNA_GEX_config.yml")
samples <- read.table('samplesheet.txt', header=TRUE)
```

# Run basic qc and clustering for all captures
Set global cutoffs for all captures
```{r}
Abbie10XCutoffs <- list(mitoRatio.max = Inf,
                      mitoRatio.min = 0,
                      nUMI.max = Inf,
                      nUMI.min = 500,
                      nGene.max = Inf,
                      nGene.min = 250,
                      log10GenesPerUMI.max = Inf,
                      log10GenesPerUMI.min = 0.80)
```

*Everything needed to specify how to run the qc analysis loop should go here*
These will eventually be the inputs for the functionalized version of the loop.
Hopefully nothing else is hard coded into the loop!
```{r}
cutoffs <- Abbie10XCutoffs
#data_dir <- 'filtered_feature_bc_matrix'
data_dir <- 'raw_feature_bc_matrix'
dataName <- "filtered_counts"
do_stages <- c("input", "filtBoth")
filterName <- do_stages[2]
# This is where we save the output
qc_plots <- list() # store the plots here
metadata_allCaps <- list() # keep only the metadata and throw away the seurat objects
filtSummary_allCaps <- list() # save counts and names of cells and genes removed the from the analysis
```

## Save only plots and metadata
Eventually I will want to save each seurat object to a file too.

```
Note that to run this on macOS, the default graphics device backend `Quartz` causes errors that prevents plotting large ggarrange plots in RStudio. See here for details: https://github.com/brentthorne/posterdown/issues/42#issuecomment-457960284
To fix this change, the graphics device backend for Rstudio to Cairo: RStudio > Tools > Global Options > General > Graphics > Graphics device backend > Cairo
You then need to install Quartz X11, restart the Mac and install some packages:
 1. Download Quartz X11 at https://www.xquartz.org , install, restart your Mac
 2. install.packages("Cairo")
 3. Test library(Cairo) - if this fails, start over (the rest is the same)
 4. install or update devtools
 5. install posterdown from GitHub
 6. install tinytex
```

```{r}
for (cap_i in 1:length(samples$Label)) {
  ## Setup env
  capID <- samples$Label[cap_i]
  CR_dir <- samples$FileID[cap_i]
  if (cap_i == 1){
    matrix_dir <- file.path(config$rootDir, config$alignmentDir,'p22090-s001_RCn19-ROi18-RSi19-RTa19-RAo18_Apr05_mmul10_HH_5A/outs/per_sample_outs/p22090-s001_RCn19-ROi18-RSi19-RTa19-RAo18_Apr05_mmul10_HH_5A/count/sample_filtered_feature_bc_matrix')
  } else if (cap_i == 2) {
    matrix_dir <- file.path(config$rootDir, config$alignmentDir,'p22090-s002_RCn19-ROi18-RSi19-RTa19-RAo18_Apr20_Mmul10_HH_5A/outs/per_sample_outs/p22090-s002_RCn19-ROi18-RSi19-RTa19-RAo18_Apr20_Mmul10_HH_5A/count/sample_filtered_feature_bc_matrix')
  }
  
  print(capID)
  
  ## Data input, qc metrics and basic clustering
  # Read in data and calculate basic qc metrics
  obj_capture <- read_counts(capID, matrix_dir)
  
  list[obj_capture, obj_filtered, filtSummary] <-
  filterThresholdsAndOutliers(obj_capture, cutoffs=cutoffs,
                              filterName=filterName,
                              by_outlier=TRUE, by_threshold=TRUE,
                              hbc_format=TRUE)
  
  # Do this for the input data and the filtered data
  for (stage in do_stages) {
    if (stage == "input") {
      tmp_obj <- obj_capture
      } else if (stage == filterName) {
        tmp_obj <- obj_filtered
      } else {
        warning("You haven't defined what to do for this stage yet!")
        break
        }
    
    # Check for influence of cell cycle
    list[tmp_obj, tmp_plots] <- checkCC(tmp_obj) # default is to not regress out cell cycle
    for (plot_name in names(tmp_plots)) {
      qc_plots[[stage]][[plot_name]][[capID]] <- tmp_plots[[plot_name]]
    }
    
    # Plot elbow plot
    (qc_plots[[stage]][["elbow"]][[capID]] <- ElbowPlot(tmp_obj))
    
    # Quick cluster and generate umap
    tmp_obj <- quickSCTandPCA(tmp_obj)
    list[tmp_obj, tmp_plot] <- quickCluster(tmp_obj)
    (qc_plots[[stage]][["umap"]][[capID]] <- tmp_plot)
    
    # Plot qc metrics
    (qc_plots[[stage]][["qc_ridges"]][[capID]] <- 
     plotQC_ridges(tmp_obj@meta.data, cutoffs=cutoffs))
    (qc_plots[[stage]][["qc_joint"]][[capID]] <- 
      plotQC_joint(tmp_obj@meta.data, cutoffs=cutoffs, color="mitoRatio"))
    
    metadata_allCaps[[stage]][[capID]] <- tmp_obj@meta.data
    filtSummary_allCaps[[stage]][[capID]] <- filtSummary
    
  }
}
print(object.size(qc_plots), units = "auto")
print(object.size(metadata_allCaps), units = "auto")
#saveRDS(qc_plots, file = here("saved_rds", "qc_plots.rds"), compress = FALSE)
#saveRDS(metadata_allCaps, file = here("saved_rds", "metadata_allCaps.rds"), compress = FALSE)
```

## qc plots for all captures
### Arrange plots
```{r}
# Merge all metadata so we can create geom_density_ridges plots for all caps
merged_metadata <- merge_metadata(metadata_allCaps)
# Store all the arranged plots here so we can call and save them more easily
arrangedPlots <- create_arrangedPlots(qc_plots, data=dataName)
```

### Save plots in arranged format
```{r}
save_arrangedPlots(arrangedPlots, data=dataName)
```


### Parallelized version
wip, do not run as is
```{r}
qc_plots <- list() # store the plots here
metadata_allCaps <- list() # keep only the metadata and throw away the seurat objects
data_dir <- 'filtered_feature_bc_matrix'
numCores <- detectCores()
getDoParWorkers()
Cluster <- makeCluster(8)
registerDoParallel(Cluster)
getDoParWorkers()
for (cap_i in 1:length(samples$Label)) {
  capID <- samples$Label[cap_i]
  CR_dir <- samples$FileID[cap_i]
  matrix_dir <- file.path(config$rootDir, config$alignmentDir, CR_dir, 'outs',
                          data_dir)
  
}
foreach (cap_i=1:length(samples$Label)) %do% {
  capID <- samples$Label[cap_i]
  CR_dir <- samples$FileID[cap_i]
  matrix_dir <- file.path(config$rootDir, config$alignmentDir, CR_dir, 'outs',
                          data_dir)
  print(capID)
}
for (cap_i in 1:length(samples$Label)) {
  ## Setup env
  capID <- samples$Label[cap_i]
  CR_dir <- samples$FileID[cap_i]
  matrix_dir <- file.path(config$rootDir, config$alignmentDir, CR_dir, 'outs',
                          data_dir)
  print(capID)
  
  ## Data input, qc metrics and basic clustering
  # Read in data and calculate basic qc metrics
  obj_capture <- read_counts(capID, matrix_dir)
  
  list[obj_capture, obj_filtBoth] <-
  filterThresholdsAndOutliers(obj_capture, cutoffs=Abbie10XCutoffs,
                              filterName="filtBoth",
                              by_outlier=TRUE, by_threshold=TRUE,
                              hbc_format=TRUE)
  
  # Do this for the input data and the filtered data
  do_stages <- c("input", "filtBoth")
  for (stage in do_stages) {
    if (stage == "input") {
      obj_capture <- obj_capture
      } else if (stage == "filtBoth") {
        obj_capture <- obj_filtBot
      } else {
        warning("You haven't defined what to do for this stage yet!")
        break
        }
    
    # Check for influence of cell cycle
    list[obj_capture, tmp_plots] <- checkCC(obj_capture) # default is to not regress out cell cycle
    for (plot_name in names(tmp_plots)) {
      qc_plots[[stage]][[plot_name]][[capID]] <- tmp_plots[[plot_name]]
    }
    
    # Plot elbow plot
    (qc_plots[[stage]][["elbow"]][[capID]] <- ElbowPlot(obj_capture))
    
    # Quick cluster and generate umap
    obj_capture <- quickSCTandPCA(obj_capture)
    list[obj_capture, tmp_plot] <- quickCluster(obj_capture)
    (qc_plots[[stage]][["umap"]][[capID]] <- tmp_plot)
    rm(list = ls(pattern="^tmp"))
    
    # Plot qc metrics
    (qc_plots[[stage]][["qc_ridges"]][[capID]] <- 
     plotQC_ridges(obj_capture@meta.data, cutoffs=Abbie10XCutoffs))
    (qc_plots[[stage]][["qc_joint"]][[capID]] <- 
      plotQC_joint(obj_capture@meta.data, cutoffs=Abbie10XCutoffs, color="mitoRatio"))
    
    metadata_allCaps[[stage]][[capID]] <- obj_capture@meta.data
    
    foreach_output <- list(qc_plots, metadata_allCaps)
  }
}
print(object.size(qc_plots), units = "auto")
print(object.size(metadata_allCaps), units = "auto")
```