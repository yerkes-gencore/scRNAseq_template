---
title: "04-pbAll-runfile"
author: "ENPRC Genomics Core"
date:  "`r Sys.Date()`"
output: 
  rmdformats::robobook:
    fig_width: 9
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = TRUE,
                      message = TRUE, 
                      echo=FALSE, 
                      fig.width = 8, 
                      fig.height = 4)
```

# Libraries

```{r}
library(tidyverse)
library(limma)
library(edgeR)
library(Seurat)
library(gencoreBulk)
library(here)

# source(here("R/limmaEdgeR_functions.R")) # only for heatmap functions, which need to be ported over to gencoreBulk from UM5 project anyway
```


# Outline of workflow

1. Read in data and create `bulk` object
  - Read in counts from STAR output
  - Add sample metadata to `bulk` object
  - Add design to `bulk` object
2. Filter by expression
  - Run `FilterByExpr()`
  - Visualize library sizes and gene counts before and after filtering
3. PCA
  - Using ggplot version of output of `plotMDS()`

## Report metadata

These variables help assign filenames to outputs and reports so you can rerun this script with different parameters without mixing up or overwriting files you want to track or compare.

```{r}
project_name <- "p00000_template"
report_number <- "04"
report_author <- "Micah Fletcher"
```

# 0 - Load data, check cell counts

## 0.1 - Load data

Load Seurat object
```{r}
### hacky way to get test data, create a reprex dataset in future
s.cd8 <- read_rds("/yerkes-cifs/runs/analyst/micah/Analysis/2023_Analyses/p21242_Satish_UM5/p21242_Satish_UM5_Analysis/saved_rds/report-13/s.cd8-HVVIV.rds")

Seurat::DefaultAssay(s.cd8) <- "RNA"
```

Load/define metadata
```{r}
## With composite grouping var as factor in a pre-defined order
sample_md <- s.cd8@meta.data %>%
  dplyr::distinct(animalID, group, challenge) %>%
  as_tibble() %>%
  arrange(desc(group), challenge) %>%
  mutate(grp_chl = paste0(group, "_", challenge) %>% fct() %>% fct_inorder(),
         animalID = animalID %>% fct() %>% fct_inorder())

## Left join back into Seurat object for plotting consistently
s.cd8@meta.data <- s.cd8@meta.data %>% left_join(sample_md, by = "animalID")
rownames(s.cd8@meta.data) <- s.cd8$cellID
```

Define project-specific metadata column names
```{r}
clust_labs <- "s.fullwnn1.0"
subjectID <- "animalID"
grp_fct <- "grp_chl"
```


## 0.2 - Check cell counts

```{r}
cell_counts_tbl <- s.cd8@meta.data %>%
  group_by(.data[[clust_labs]], .data[[subjectID]], .data[[grp_fct]]) %>%
    count() %>%
  ungroup() %>%
  pivot_wider(names_from = all_of(clust_labs), values_from = n, values_fill = 0) %>%
  mutate(nCells_total = rowSums(select(., -all_of(subjectID), -all_of(grp_fct)))) %>%
  pivot_longer(cols = -c(all_of(subjectID), all_of(grp_fct), nCells_total), values_to = "n", names_to = clust_labs) %>%
  mutate(p = n/nCells_total)
```

### Scatter plot: split by `group`, colored by `cell type label`, y = `cell type label`

A minimum of 10 cells (dashed gray line) is typically required for aggregation into a pseudobulk sample.

```{r, fig.width=8, fig.height=6, warning = FALSE}
cell_counts_tbl %>%
  ggplot(aes(y = fct_rev(.data[[clust_labs]]), color = .data[[clust_labs]], x = n)) +
    geom_point(size=3,  
               position = position_jitterdodge(jitter.width = 0, dodge.width = 1)) +
    geom_vline(xintercept = 10, color = "gray", linetype = "dashed") +
    theme_bw() +
    scale_x_log10() +
    facet_wrap(~.data[[grp_fct]], ncol = 4) +
    theme(strip.background = element_rect(fill="white")) +
    xlab("n cells") +
    ylab(clust_labs)
```

### Stacked bar plots; arranged by `animalID`, `group`, `challenge`
```{r, fig.height=4, fig.width=8}
cell_counts_tbl %>%
  ggplot(aes(x = .data[[subjectID]], y = p, fill = .data[[clust_labs]])) +
    geom_bar(stat = "identity", color = "black") +
  theme_classic() +
  facet_grid(rows = ~.data[[grp_fct]], scales = "free_x", space = "free") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(angle=90, vjust=0.5, hjust=1)) +
  ylab("Proportion of cells")
```

## 0.3 - Choose samples and clusters to include in pseudobulk aggregations

<!-- Note: Dropped samples in the template are because of differential loading of sorted cells, which isn't obvious from the above plots -->

Drop problematic samples
```{r}
samples2drop <- c("RCw18", "RYr18")
samples2drop_cellIDs <- s.cd8@meta.data %>%
    filter(.data[[subjectID]] %in% samples2drop) %>% rownames()
s.filt <- s.cd8 %>% 
  subset(cells = samples2drop_cellIDs, invert = TRUE)
sample_md <- sample_md %>% 
  filter(!(.data[[subjectID]] %in% samples2drop)) %>% 
  mutate({{ subjectID }} := fct_drop(.data[[subjectID]], samples2drop))
```

Drop problematic clusters
```{r}
clusters2drop <- c()
clusters2drop_cellIDs <- s.filt@meta.data %>%
    filter(.data[[clust_labs]] %in% clusters2drop) %>% rownames()
s.filt <- s.filt %>% subset(cells = clusters2drop_cellIDs, invert = TRUE)
```


# 1 - Create list of `bulk` objects

## 1.0 - Custom functions

```{r}
createPBobj <- function(seurat_obj, aggregate_by = NULL, subjectID = "animalID", arrange_by = NULL,
                        sample_md = NULL, design_str = NULL, split_clusters = F) {
  ## Convert Seurat obj to PB
  pb_obj <- list()
  ## Splitting clusters before pseudobulking
  if (split_clusters) {
    suppressWarnings({ # warns if only one cluster but we want that
    pb_obj <- seurat_obj %>% 
      Seurat::SplitObject(split.by = aggregate_by) %>%
        lapply(., function(x) {
          dge <- x %>%
            edgeR::Seurat2PB(sample = subjectID, cluster = aggregate_by)
          # # Seurat2PB appends cluster name to colname, but we don't want that
          # colnames(dge) <- dge$samples$sample
          colnames(dge) <- str_remove(colnames(dge), pattern = "_cluster*$")
          # Add sample metadata
          dge$samples <- dge$samples %>%
            rownames_to_column(var = "rownames") %>%
            select(-group) %>%
            left_join(sample_md, by = c("sample" = subjectID)) %>%
            arrange(.data[[arrange_by]]) %>%
            mutate(sample = fct(sample) %>% fct_inorder())
          rownames(dge$samples) <- dge$samples$rownames
          # Arrange counts columns in same order as samples table
          dge$counts <- dge$counts[,match(rownames(dge$samples), colnames(dge$counts))]
          # Calculate library normalization factors for use downstream when removing heterscedascity with voom
          dge$samples$norm.factors <- edgeR::calcNormFactors(dge$counts, method = "TMM")
          # Create "bulk" object
          bulk <- list()
          bulk$dge <- dge
          # Add design to bulk$md
          bulk$md$design <- stats::model.matrix(as.formula(design_str), dge$samples)
          return(bulk)
        })
  })
  ## Arrange clusters in alphabetical order
  pb_obj <- pb_obj[order(names(pb_obj))]
  return(pb_obj)
  }
  ## Not splitting clusters before pseudobulking
  else if (!split_clusters) {
    dge <- seurat_obj %>%
      edgeR::Seurat2PB(sample = subjectID, cluster = aggregate_by)
    # Add sample metadata
    dge$samples <- dge$samples %>%
      rownames_to_column(var = "rownames") %>%
      select(-group) %>%
      left_join(sample_md, by = c("sample" = subjectID)) %>%
      arrange(cluster, .data[[arrange_by]]) %>%
      mutate(sample = fct(sample) %>% fct_inorder())
    rownames(dge$samples) <- dge$samples$rownames
    # Arrange counts columns in same order as samples table
    dge$counts <- dge$counts[,match(rownames(dge$samples), colnames(dge$counts))]
    # Calculate library normalization factors for use downstream when removing heterscedascity with voom
    dge$samples$norm.factors <- edgeR::calcNormFactors(dge$counts, method = "TMM")
    # Create "bulk" object
    bulk <- list()
    bulk$dge <- dge
    # Add design to bulk$md
    bulk$md$design <- stats::model.matrix(as.formula(design_str), dge$samples)
    return(bulk)
  }
}
```

```{r}
bulk <- createPBobj(s.filt, aggregate_by = clust_labs, 
                    subjectID = subjectID, sample_md = sample_md, 
                    arrange_by = "challenge", split_clusters = F,
                    design_str = "~ 0")

bulk$dge$samples <- bulk$dge$samples %>%
  mutate(clust_chl = paste0(cluster, "_", challenge))

bulk$md$design <- stats::model.matrix(~ clust_chl, dge$samples)
colnames(bulk$md$design) <- str_replace(colnames(bulk$md$design), "clust_chl", "clust")
```

# 2 - Filter by expression

"The filtering should be based on the grouping factors or treatment factors that will be involved in the differential expression teststested for, rather than on blocking variables that are not of scientific interest in themselves." 

So if you may need to change the `design = bulk$md$design` to `group = {factor of biological interest}` if you've included nuisance variables in the deisgn. See page 14 of EdgeR manual for details: https://www.bioconductor.org/packages/devel/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf

```{r}
keep.exprs <- filterByExpr(bulk$dge, design = bulk$md$design)
```

## 2.0 - Custom functions

```{r}
counts_kept_tbl <- bulk$dge$counts %>%
  dplyr::as_tibble(rownames = "gene") %>%
  dplyr::left_join(dplyr::tibble(gene = names(keep.exprs), keep = keep.exprs), 
                   by = c("gene")) %>%
  tidyr::pivot_longer(cols = -c("gene", "keep"), names_to = "rownames", values_to = "counts") %>%
  tidyr::separate(.data$rownames, into = c("sample", "cluster"), sep = "_cluster") %>%
  dplyr::mutate(sample = forcats::fct(.data$sample, levels = levels(dge$samples$sample)),
                is_zero = .data$counts == 0)
```

## 2.1 - Gene filtering by expression

```{r, fig.width = 6, fig.height = 4, message=F}
counts_kept_tbl %>%
  dplyr::group_by(.data$sample, .data$cluster) %>%
  dplyr::summarize(keep_zero = sum(.data$is_zero & .data$keep),
                   keep_nonzero = sum(!.data$is_zero & .data$keep),
                   remove_zero = sum(.data$is_zero & !.data$keep),
                   remove_nonzero = sum(!.data$is_zero & !.data$keep)) %>%
  dplyr::ungroup() %>%
  tidyr::pivot_longer(cols = c(starts_with("keep_"), starts_with("remove_")), names_to = "cat", values_to = "n_genes") %>%
  dplyr::mutate(cat = forcats::fct(.data$cat, levels = rev(c("keep_nonzero", "keep_zero", "remove_nonzero", "remove_zero")))) %>%
  ggplot(aes(y = .data$sample, x = .data$n_genes, fill = .data$cat)) +
  geom_bar(stat="identity") +
  scale_fill_manual(name = "Filtering",
                    values = c("keep_nonzero"="green2", "keep_zero"="yellow2",
                               "remove_nonzero"="orange", "remove_zero"="red"),
                    breaks = c("keep_nonzero", "keep_zero",
                               "remove_nonzero", "remove_zero"),
                    labels = c("Kept non-zero", "Kept zero",
                               "Removed non-zero", "Removed zero")) +
  xlab("Gene counts") + ylab("Sample ID") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  facet_wrap(~cluster)
```


## 2.2 - Library sizes of discarded and kept data
```{r, fig.width = 6, fig.height = 4, message=F}
counts_kept_tbl %>%
  dplyr::group_by(.data$sample, .data$cluster, .data$keep) %>%
    dplyr::summarize(lib.size = sum(counts)) %>%
  dplyr::ungroup() %>%
  ggplot(aes(y = sample, x = lib.size, fill = keep)) +
  geom_bar(stat="identity") +
  xlab("Library size (sum of counts)") + ylab("sample") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  facet_wrap(~cluster)
```

## 2.3 - Apply the filter
```{r}
## Save the prefiltered data in case you want to compare
bulk_prefilt <- bulk

## Apply the filter
bulk$dge <- bulk$dge[keep.exprs, , keep.lib.sizes=FALSE]
```


# 3 - Variance-mean trends and PCA

## 3.1 - Mean-variance trend by group (i.e. voomByGroup)

<!-- This is not necessary when separating clusters into different bulk experiments (except in cases with repeated measures). -->

```{r}
voomByGroup(counts = bulk$dge$counts,
            design = bulk$md$design,
            group = bulk$dge$samples$sample,
            plot = "combine", save.plot = TRUE)
```

## 3.2 - PCA plot

```{r, fig.width=8, fig.height=8}
ggplotMDS(bulk$dge, gene.selection = "common",
          sampleID = "rownames", color = "challenge", path = "cluster")
```

## 3.3 - MDS plot

Multidimensional scaling plot; distances correspond to BCV between pairs of samples. Pairwise BCVs were computed from the 500 most heterogeneous genes. See ?limma::plotMDS() for details.

[McCarthy et al. 2012](https://academic.oup.com/nar/article/40/10/4288/2411520)
> Biological coefficient of variation is the coefficient of variation with which the (unknown) true abundance of the gene varies between replicate RNA samples. It represents the CV that would remain between biological replicates if sequencing depth could be increased indefinitely. 

```{r, fig.width=8, fig.height=8}
ggplotMDS(bulk$dge, gene.selection = "pairwise",
          sampleID = "rownames", color = "challenge", path = "cluster")
```

# 4 - Write rds

## Create a subdir name and keep it consistent across dirs

```{r}
## Subdir name for `outputs` and `rds`
subdir <- paste0("report-", report_number, "-QC")
## Formatted date for filenames
getDate <- function() {
  format(Sys.Date(), "%Y%m%d")
}
```

## Write `bulk` rds
```{r}
if (!dir.exists(here("saved_rds/", subdir))) {
  dir.create(here("saved_rds/", subdir))
}

pb_prefilt %>%
  write_rds(., here("saved_rds/", subdir, paste0("pb_prefilt-", getDate(), ".rds")))
pb %>%
  write_rds(., here("saved_rds/", subdir, paste0("pb-", getDate(), ".rds")))
```

# 5 - Render report

## Set filenames

```{r}
report_filename_QC <- paste0(project_name, "-", 
                             report_number, "-",
                             "QC-", 
                             format(Sys.Date(), "%Y%m%d"), ".html")
```


## Render
```{r}
rmarkdown::render(input = here("analysis_scripts/04-pseudobulk-qc-format.Rmd"),
                  output_file = report_filename_QC,
                  output_dir = here('reports'))
```
