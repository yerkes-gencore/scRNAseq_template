---
title: "Project management best practices"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Project management best practices}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## General workflow

If you find yourself pointing to locations outside the project directory,
consider making a copy or symlink within the project directory. 

If you find yourself constantly saving out Rds objects within the same script,
consider if the script should be split up with a single Rds for the entry/exit
points. This avoids accidentally working with the wrong object,
running steps out of order, and keeps your working environment smaller/tidier.

## Report format files

You can utilize the runfile:formatfile workflow to manage the aesthetics
of a rendered report separate from the major computational intensive
lines. Have one script generate all the environment variables you need
for the report, then have a separate report with the markdown syntax and plots.
This allows you to quickly render reports to make small aesthetic changes without
waiting for the processing lines to run again. It also allows you to present
data in a different order than you generated it. 
E.g:

```{r}
## This only works if all the variables called in the format file 
## are in the current environment. Check the format file to tweak
## aesthetics 
rmarkdown::render(here('analysis_scripts/02_processing_template.format.Rmd'),
                  output_file = '02_processing_report.html',
                  output_dir = here('reports'))
```

## Dockerized Rstudio server

Dockerized sessions of Rstudio ensure a reproducible architecture for all analyses. 
There is a dockerfile for the gencore Rstudio image at
`/yerkes-cifs/runs/tools/rstudio-server/`, or better yet at
https://github.com/yerkes-gencore/rstudio-server, or even better yet at
https://hub.docker.com/repository/docker/dgratz100/gencore-singlecell-rstudio/general.
Using the gencore dockerized Rstudio
allows use of the Renv cache to avoid re-downloading packages in each container (see the
next session). We try to keep the dockerfile minimal, but if there are linux dependencies
or other installations that are useful, consider updating the dockerfile for 
full reproducibility. 

You can build the image from the dockerfile using Docker (or Podman)

```
cd /yerkes-cifs/runs/tools/rstudio-server/
git pull ## make sure the dockerfile is up-to-date!
podman build -t gencore/rstudio:<your r version here> .
```

or by just pointing to the dockerhub version

```
podman build dgratz100/gencore-singlecell-rstudio
```

then you can run the container (ideally behind a screen or other session manager
to avoid random detachments). It can be useful to set `ROOT=TRUE` in case you 
need to install linux dependencies from the terminal.

```
podman run -e PASSWORD=password -e ROOT=TRUE -p 8787:8787 dgratz100/gencore-singlecell-rstudio
```

Note that the port number may need to change to avoid conflicts with other users, 
but you also may need to allow that port through the firewall if it has not been
already. The following command will allow the port through, or tell you if
it already is. the 'tcp' specification is the protocol needed to use rstudio server
through the port.

```
sudo firewall-cmd --add-port=8787/tcp
```

For some unknown reason, rstudio server sessions don't seem
to recognize git tracking set up not through rstudio server.
So if you want to use rstudio's built in git interface,
you'll have to create a new project from a git tracked repo,
rather than creating the git tracked repo first and creating
a new project later.

### Mounts

You will likely want to just mount the whole server in the same style as the actual server.
This will keep filepaths consistent between the server and the dockerized image, which
is especially relevant for symlinks or paths in your code. 

`-v /yerkes-cifs:/yerkes-cifs`

You will also likely want to have an `.Renviron` file that is mounted with
your containers. This can store variables like your github PAT and 
Renv shared cache path (see Renv section) across sessions and projects.

`-v <path_to_saved_configs/.Renviron:/root/.Renviron`

The path for these user level mounted

The dockerized rstudio also has issues with editing the ~/.local file, not sure why. You may have to mount folders there as necessary to work with things like `SeuratData`, or manually chmod and create the folders from the terminal as sudo. 

## Renv

[See the site for full details](https://rstudio.github.io/renv/articles/renv.html)

Renv is an R package that captures versions of packages used in a project. It can help you use different versions of packages for different projects. This is useful for making reproducible workflows, allowing you to jump back to old projects and share projects with other users. 

One advantage of Renv is having a cache of packages to avoid having multiple installs of the same package/version. If you plan to consistently use renv on a shared system, it may be worthwhile to edit the shared cache location as part of your user-level .Renviron, so you don't have to set it for each project. `usethis::edit_r_environ()` can help you edit that file.
This is especially useful if you want to have multiple users access the project on a shared file system. Assuming you've followed the tutorial to set up renv in your project, you can point the project to a shared library cache via an environmental variable.
[https://support.posit.co/hc/en-us/articles/360047157094-Managing-R-with-Rprofile-Renviron-Rprofile-site-Renviron-site-rsession-conf-and-repos-conf](more info)

Edit .Renviron

`RENV_PATHS_ROOT='/Volumes/yerkes/genomelab/illumina/runs/tools/renv/'`

Or .Rprofile

`Sys.setenv(RENV_PATHS_ROOT = "/Volumes/yerkes/genomelab/illumina/runs/tools/renv")`

To use renv, run renv::init() in a project opened in rstudio. This can take a long time to run at first, as you will have to copy versions of packages used from your local disk to the server. Once they are in the cache/project, your workflow continues like normal. Note that if you want to set up the project to use the shared drive cache, you should set that up before running init, otherwise it will use a project-local cache.

Once `renv` is installed, you should install pacakges through `renv::install()`. This handles the proper workflow caching and lockfile updating for you. 

## Version tracking
