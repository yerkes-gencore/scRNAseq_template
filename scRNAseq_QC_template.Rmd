---
title: 'QC'
author: "Emory Gencore"
date: '`r Sys.Date()`'
output:   
  rmdformats::robobook:
    fig_width: 8
    gallery: true
    thumbnails: false
  
---

<style type="text/css">
.book .book-body .page-inner {
  max-width: 1600px;
  margin-left: auto;
  margin-right: auto;
}
</style>


```{r, include=FALSE}
library(Seurat)
library(tidyverse)
library(reshape2)
library(SingleR)
library(ape)
library(MAST)
library(glmGamPoi)
library(kableExtra)
library(SoupX)
library(gridExtra)
library(DoubletFinder)
#library(SC3)
library(rngtools)
library(ggrepel)
library(clustree)
#library(package = affyLib, )
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE, cache=FALSE, cache.lazy = FALSE)#, include=FALSE)
config <- yaml::yaml.load_file("scRNA_GEX_config.yml")
source('scRNAseq_functions.R')
# recluster <- FALSE
# resave_combined_obj <- FALSE
preran=TRUE
```

# Sequencing metrics

```{r}
samples <- read.table('samplesheet.txt', header=TRUE)
qc_metrics <- capture_QC_metrics(samples)
#DT::datatable(qc_metrics, options = list(searching=FALSE, pageLength=20, lengthMenu=NULL))
knitr::kable(qc_metrics)
```

```{r, fig.width=14, fig.height=4}
a <- c("Estimated Number of Cells", "Mean Reads per Cell", "Median Genes per Cell", "Number of Reads", "Reads Mapped Confidently to Genome", "Fraction Reads in Cells", "Total Genes Detected", "Median UMI Counts per Cell")
qc_metrics <- gsub(",", "", qc_metrics)
qc_metrics <- gsub("%", "", qc_metrics)
qc_metrics <- as.data.frame(qc_metrics)
qc_metrics[] <- sapply(qc_metrics, as.numeric)#%>% mutate_all(function(x) as.numeric(as.character(x)))
ggplot(melt(t(qc_metrics[rownames(qc_metrics) %in% a,])), aes(x=Var1, y=value, fill=Var1)) + geom_col()+ facet_wrap(vars(Var2 ), ncol = 4, scales='free_y') + theme_bw() + labs(x=NULL, y=NULL, fill="Sample") #+ scale_y_continuous(limits=c(0,NA))
```

***

# Removing ambient RNA

```{r}
create_objects_soupX <- function(label, file, mito.pattern = "^mt-", ribo.pattern="^Rp[sl]", soupX = TRUE, multi=FALSE, min.cells=10, min.features=0) {
  filtered_data <- Read10X(dir(file.path(config$rootDir, config$alignmentDir, file, 'outs'), recursive = TRUE, pattern = 'filtered_feature_bc_matrix$', include.dirs = TRUE, full.names = TRUE))
  if (soupX){
    clus <- read.csv(file.path(dir(file.path(config$rootDir, config$alignmentDir, file, 'outs'), recursive = TRUE, pattern = 'clustering', include.dirs = TRUE, full.names = TRUE), 'gene_expression_graphclust/clusters.csv'))
    clusters <- clus$Cluster
    names(clusters) <- clus$Barcode
    unfiltered_data <- Read10X(dir(file.path(config$rootDir, config$alignmentDir, file, 'outs'), recursive = TRUE, pattern = 'raw_feature_bc_matrix$', include.dirs = TRUE, full.names = TRUE))
    sc <- SoupChannel(tod = unfiltered_data, toc = filtered_data)
    sc <- setClusters(sc, clusters)
    sc <- autoEstCont(sc)
    fixed_counts <- adjustCounts(sc, roundToInt = TRUE)
    compare <- 1- (rowSums(fixed_counts) / rowSums(filtered_data)) 
    count_diff <- data.frame(diff=compare, total=rowSums(filtered_data)) %>% rownames_to_column('Gene')
    # boxplot(compare)
    # count_diff <- fixed_counts / filtered_data 
    # 
    # count_diff <- count_diff[order(compare, decreasing = TRUE),]
    # count_diff <- count_diff[!is.na(compare),]
    # count_diff <- head(count_diff, 20)
    # count_diff <- melt(as.data.frame(t(count_diff)))
    print(ggplot(count_diff, aes(x=diff, y=total, label=Gene)) + geom_point(color='grey', alpha=0.5) + geom_text_repel(data=subset(count_diff, diff > 0.25 | total > 1000000), position=position_jitter())+ scale_y_log10() + labs(x='Portion of reads removed', y='Original count total', title = label) + theme_bw() )
    # print(ggplot(count_diff, aes(x=variable, y=value)) + geom_boxplot(outlier.size = .1) + coord_flip() + labs(y='Counts removed', x=NULL, caption = 'Each point is a single cell') + theme_bw())
    filtered_data <- fixed_counts
  }  
  unhashed <- CreateSeuratObject(counts=filtered_data, project = label, min.cells = min.cells, min.features=min.features)
  unhashed <- NormalizeData(unhashed)
  unhashed <- FindVariableFeatures(unhashed)
  unhashed <- ScaleData(unhashed)
  unhashed <- CellCycleScoring(unhashed, s.features=s.features, g2m.features = g2m.features)
  unhashed[["percent.mito"]] <- PercentageFeatureSet(unhashed, pattern=mito.pattern)
  unhashed[["percent.ribo"]] <- PercentageFeatureSet(unhashed, pattern=ribo.pattern)
  unhashed
  #unhashed <- RunPCA(unhashed)
  
  
  
  
}


```


```{r}
s.features <- str_to_title(cc.genes$s.genes)
g2m.features <-  str_to_title(cc.genes$g2m.genes)
captures <- mapply(create_objects_soupX, samples$Label, samples$FileID, multi=TRUE)
#names(captures) <- samples$Label
#saveRDS(captures, file='saved_rds/unfiltered_captures.Rds')
if (preran){
  captures <- readRDS('saved_rds/unfiltered_captures.Rds')
} else {

  saveRDS(captures, file='saved_rds/unfiltered_captures.Rds')
  #captures <- mapply(create_hashed_objects, samples$FileID, samples$Label, hash_table=hash_table, mito.pattern = "^MT", ribo.pattern="^RP[SL]")

}
```


***

# Filtering extremes

```{r, fig.width = 6,include=FALSE}
cutoffs <- lapply(captures, qc_vln_plots, bootstrap=FALSE)
```

```{r, include=FALSE}
##edit cutoffs if desired 
## Mito
cutoffs[[1]][2,3] <- 10
cutoffs[[2]][2,3] <- 10
## Ncount
cutoffs[[1]][1,2] <- 500
cutoffs[[2]][1,2] <- 500
cutoffs[[1]][2,2] <- 75000
cutoffs[[2]][2,2] <- 75000
## Nfeature
cutoffs[[1]][1,1] <- 200
cutoffs[[2]][1,1] <- 200
cutoffs[[1]][2,1] <- 8000
cutoffs[[2]][2,1] <- 8000

#then apply
my_subset <- function(capture, cutoffs) {
  filt <- subset(capture, subset = nFeature_RNA > cutoffs$nfeature[1] & nFeature_RNA < cutoffs$nfeature[2] &
           percent.mito < cutoffs$mito[2] & nCount_RNA > cutoffs$ncount[1] & nCount_RNA < cutoffs$ncount[2] )
  print(paste0('Removing ', ncol(capture) - ncol(filt), ' cells of ', ncol(capture), ' from capture ', capture@project.name, ' due to quality threshold cutoffs'))
  return(filt)
}
captures <- mapply(my_subset, captures, cutoffs)
# captures$`LysM-cre` <- subset(captures$`LysM-cre`, subset = nFeature_RNA > 400 & nFeature_RNA < 4500 & percent.mito < 10)
# captures$`Ptpn11-E76K-pos-LysM-cre` <- subset(captures$`Ptpn11-E76K-pos-LysM-cre`, subset = nFeature_RNA > 400 & nFeature_RNA < 7000 & percent.mito < 10)
```

```{r}
lapply(captures, function(x){ 
       plot1 <- FeatureScatter(x, feature1 = "nCount_RNA", feature2 = "percent.mito") + theme(legend.position="none")
       plot2 <- FeatureScatter(x, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") + theme(legend.position="none")
       plot1 + plot2
})
```


<!-- # Removing doublets {.tabset} -->

<!-- ## Determine clusters, regress cell cycle -->

```{r, include=FALSE}
sct_and_pca <- function(obj){
  obj <- SCTransform(obj, vars.to.regress=c('S.Score', 'G2M.Score'))
  obj <- RunPCA(obj)
  obj
}
captures <- lapply(captures, sct_and_pca)
```

```{r, include=FALSE}
lapply(captures, function(x) ElbowPlot(x, ndims=30))
```

```{r, include=FALSE}
npcs <- c(11,11)
captures <- mapply(function(object, npcs) FindNeighbors(object, dims=1:npcs, verbose=FALSE),
                   object = captures, npcs = npcs)
captures <- mapply(function(object, npcs) RunUMAP(object, dims=1:npcs, reduction='pca'),
                   object = captures, npcs = npcs)
```

```{r, fig.width=8, fig.height=6, results='hide', fig.keep='all', include=FALSE}
plot_metadata <- function(data){
  #a1<- DimPlot(data, group.by = 'HTO_classification.global')
  a2<- FeaturePlot(data, reduction='umap', features="nFeature_RNA") + ggtitle("Unique features count")
  a3<- FeaturePlot(data, reduction='umap', features="nCount_RNA") + ggtitle("Total RNA count")
  a4<- FeaturePlot(data, reduction='umap', features="percent.mito") + ggtitle("Mitochondrial feature percentage")
  a5 <-  grid.arrange(a2,a3,a4)
  a5
  }
lapply(captures, plot_metadata)
```

```{r, results='hide', fig.keep='all', include=FALSE}
## Run this separately for each capture to find a resolution for that capture 
## based on above metadata to isolate clusters to remove
res <- c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1)

resplots <- function(res, x){
  x <- FindClusters(x, resolution = res, verbose=FALSE)
  DimPlot(x, reduction='umap', label=TRUE)
}
lapply(res, resplots, x=captures$`Ptpn11-E76K-pos-LysM-cre`)
```

```{r Removing_clusters, results='hide', fig.keep='all', include=FALSE}
resolutions <- c(0.4, 0.2)
clusters_to_remove <- list(
  c(),
  c()
)
captures <- mapply(FindClusters, captures, resolution = resolutions)



captures <- mapply(function(data, sub){
  data <- subset(data, subset = seurat_clusters %in% sub, invert = TRUE)
  data@meta.data$seurat_clusters <- droplevels(data@meta.data$seurat_clusters)
  return(data)
  },
               captures, clusters_to_remove)
```

```{r reclustering_after_removal, include=FALSE}
if (!is.null(unlist(clusters_to_remove))){
  captures <- lapply(captures, FindNeighbors, dims=1:npcs, verbose=FALSE)
  captures <- lapply(captures, RunUMAP, reduction='pca', dims=1:npcs)
  captures <- mapply(FindClusters, captures, resolution = resolutions)
}

```

```{r, include=FALSE}
lapply(captures, DimPlot)
```

***

# Remove doublets

```{r, include=FALSE}
doublet_finder_nohash <- function(obj, pcs, cores = 1, doublet_rate = 0.075){
  sweep.res.list <- paramSweep_v3(obj, PCs = 1:pcs, sct = TRUE, num.cores = cores)
  sweep.stats <- summarizeSweep(sweep.res.list, GT = FALSE)
  bcmvn <- find.pK(sweep.stats)
  pK <- bcmvn[bcmvn$BCmetric==max(bcmvn$BCmetric),'pK']
  annotations <- obj@meta.data$seurat_clusters
  homotypic.prop <- modelHomotypic(annotations) ## ex: annotations <- seu_kidney@meta.data$ClusteringResults
  nExp_poi <- round(doublet_rate*nrow(obj@meta.data))  ## Assuming 7.5% doublet formation rate - tailor for your dataset
  nExp_poi.adj <- round(nExp_poi*(1-homotypic.prop))
  results <- doubletFinder_v3(obj, PCs = 1:pcs, pK = as.numeric(as.character(pK)), nExp = nExp_poi.adj, sct = TRUE)
  return(results)
}

```

```{r, include=FALSE}
if (preran){
  captures <- readRDS('saved_rds/doublet_detected_captures.rds')
} else {
  captures <- mapply(doublet_finder_nohash, captures, npcs)
  saveRDS(captures, 'saved_rds/doublet_detected_captures.rds')
}
```


```{r}
filter_doublets <- function(capture, hash) {
  #neg_idx <- capture$HTO_classification.global=='Negative'
  x <- capture
  print(capture@project.name)
  df_column <- colnames(capture@meta.data)[grepl('DF.classifications', colnames(capture@meta.data))]
  if (hash){
    doub_idx <- capture$HTO_classification.global=='Doublet' | capture[[df_column]] == 'Doublet'
    print(paste0('Removing ', as.character(sum(doub_idx)), ' doublet GEMS'))
    x <- subset(capture, HTO_classification.global=='Singlet')
  } else {
    doub_idx <- capture[[df_column]] == 'Doublet'
    print(paste0('Removing ', as.character(sum(doub_idx)), ' doublet GEMS'))
  }
  colnames(x@meta.data)[ncol(x@meta.data)] <- 'DF.classifications'
  x <- subset(x, DF.classifications=='Singlet')
  x@meta.data <- droplevels(x@meta.data )
  return(x)
}

captures <- lapply(captures, filter_doublets, hash = FALSE)
```

```{r}
#saveRDS(captures, file='saved_rds/filtered_captures.Rds')
if (preran){
  captures <- readRDS('saved_rds/filtered_captures.Rds')
} else {

  saveRDS(captures, file='saved_rds/filtered_captures.Rds')
}
```

***

# Capture level clusters

```{r, include = FALSE}
lapply(captures, function(x) ElbowPlot(x, ndims=30))
```

```{r, include=FALSE}
npcs <- c(11,11)
# captures <- lapply(captures, FindNeighbors, dims=1:npcs, verbose=FALSE)
# captures <- lapply(captures, RunUMAP, reduction='pca', dims=1:npcs)
# #captures <- mapply(FindClusters, captures, resolution = resolutions)
captures <- mapply(function(object, npcs) FindNeighbors(object, dims=1:npcs, verbose=FALSE),
                   object = captures, npcs = npcs)
captures <- mapply(function(object, npcs) RunUMAP(object, dims=1:npcs, reduction='pca'),
                   object = captures, npcs = npcs)
```

```{r}
lapply(captures, DimPlot)
```

***

# Integrate samples

Selecting optimal clustering, with tree of how clusters change with different resolutions

```{r, include=FALSE, eval=!preran}
# captures <- lapply(captures, function(x){
#   x <- AddMetaData(x, metadata = paste(x$orig.ident, x$HTO_classification, sep = ':'), col.name='ID')
# })
# split.obj <- unlist(lapply(captures, SplitObject, split.by = 'HTO_classification'))
for (n in 1:length(captures)){
  DefaultAssay(captures[[n]]) <- 'SCT'
}
ftrs <- SelectIntegrationFeatures(captures)
captures <- PrepSCTIntegration(captures, anchor.features = ftrs)
anchors <- FindIntegrationAnchors(captures, anchor.features = ftrs, normalization.method = 'SCT')

## https://github.com/satijalab/seurat/issues/3930
if (min(unlist(lapply(captures, ncol))) < 50){
  message('Waring: your smallest split object has fewer than 50 cells. Make sure this is correct before moving forward, it may have impacts on integration')
}

combined.obj <- IntegrateData(anchors, normalization.method = 'SCT', k.weight = min(unlist(lapply(captures, ncol)), 100))
```

```{r}
if (preran) {
  combined.obj <- readRDS('saved_rds/combined_obj.rds')
} else {
  saveRDS(combined.obj, 'saved_rds/combined_obj.rds')
}
```

```{r, include=FALSE}
combined.obj <- RunPCA(combined.obj)
ElbowPlot(combined.obj, ndims = 30)
```

```{r, include=FALSE}
npcs = 13
combined.obj <- FindNeighbors(combined.obj, dims=1:npcs, verbose=FALSE)
combined.obj <- RunUMAP(combined.obj, reduction='pca', dims=1:npcs)
```

<!-- ## Clustering tree -->

```{r, fig.width=12, fig.height=6}
testclustree <- FindClusters(combined.obj, resolution = c(0.1,0.3,0.4,0.7), verbose=FALSE)
clustree(testclustree) +
    guides(edge_colour = FALSE) + theme(legend.position = "top")
```


```{r, results='hide', fig.keep='none'}
res <- c(0.25,0.3,0.35)
resplots <- function(res, x){
  x <- FindClusters(x, resolution = res, verbose=FALSE)
  DimPlot(x, reduction='umap', label=TRUE, group.by = paste0("integrated_snn_res.", res))
}
lapply(res, resplots, x=combined.obj)
```

```{r}
res = 0.3
print(paste0('Selected resolution of ', res))
combined.obj <- FindClusters(combined.obj, resolution = res, verbose=FALSE)
#combined.obj <- RunTSNE(combined.obj)
DimPlot(combined.obj, reduction = 'umap', label=TRUE)
```

# Final integrated dataset


```{r, fig.width = 8, fig.height = 8}
FeaturePlot(combined.obj, reduction='umap', features=c("nCount_RNA", 'nFeature_RNA', 'percent.mito', 'percent.ribo'), ncol = 2)
```

```{r, fig.width=8}
DimPlot(combined.obj, split.by = 'orig.ident', label=TRUE)
```

How much of each capture is in each cluster

```{r}
tmp <- as.data.frame.matrix(table(combined.obj$seurat_clusters, combined.obj$orig.ident))
knitr::kable(tmp, caption = 'Number of cells')
tmp <- tmp %>% mutate(across(.cols= everything(), ~ 100*.x / sum(.x))) #, .names = "{.col}_percent"
knitr::kable(tmp, caption = 'Percentage of cells from capture', digits = 1)
```


```{r}
if (!preran){
  saveRDS(combined.obj, file='saved_rds/combined_obj.Rds')
  #captures <- mapply(create_hashed_objects, samples$FileID, samples$Label, hash_table=hash_table, mito.pattern = "^MT", ribo.pattern="^RP[SL]")
  
}
```




