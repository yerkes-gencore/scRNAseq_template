---
title: 'p22090 Tiffany QC'
author: "Emory Gencore"
date: '`r Sys.Date()`'
output: 
  rmdformats::readthedown:
    fig_width: 9
    toc_depth: 1
---

<style type="text/css">
 #content {
   max-width: 1200px;
 }
</style>

```{r, include=FALSE}
library(Seurat)
library(tidyverse)
library(reshape2)
library(SingleR)
library(ape)
library(MAST)
library(glmGamPoi)
library(kableExtra)
library(SoupX)
library(gridExtra)
library(DoubletFinder)
library(rngtools)
library(ggrepel)
library(clustree)
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE,
                      fig.width = 8, fig.height = 6,
                      cache=FALSE, cache.lazy = FALSE)#, include=FALSE)
config <- yaml::yaml.load_file("scRNA_GEX_config.yml")
source('scRNAseq_functions.R')
```

```{r slow_chunk_flags}
load_and_preprocess_counts = TRUE
perform_soupX = TRUE
run_doubletFinder = TRUE
hashed = TRUE
preran = TRUE
report_only = TRUE
```

```{r}
## Need HTO and Label columns for premade demultiplexing functions
hash_table <- data.frame(
  'Label'=c('RAo18',
'RCn19',
'ROi18',
'RSi19',
'RTa19',
'Rta19',
'ROi18',
'RAo18',
'RCn19',
'Rsi19'),
  'ID'=c('98677',
'98678',
'98679',
'98680',
'98681',
'98681',
'98679',
'98677',
'98678',
'98680'),
  'Timepoint'=c(rep('Apr05', 5), rep('Apr20', 5)),
loaded=c(4223,
6940,
318,
1058,
14104,
22344,
10012,
12627,
3323,
3377)
  )
hash_table$HTO <- plyr::mapvalues(hash_table$ID, from=c(98677,98678,98679,98680,98681), to=c('Hash1Human','Hash2Human','Hash3Human','Hash4Human','Hash5Human'))
```

Project description:

`r config$description`

# Sequencing metrics {.tabset}

```{r}
samples <- read.table('samplesheet.txt', header=TRUE)
qc_metrics <- capture_QC_metrics_hashed(samples)
```

## Summary

Antibody capture summary

```{r}
short <- qc_metrics %>% filter(Category=='Cells', Library.Type=='Antibody Capture') %>% select(ID, Metric.Name, Metric.Value)
cnames <- short$Metric.Value
short <- short %>% reshape(idvar="ID",timevar = "Metric.Name", direction='wide') 
short <- rename_with(short, ~ gsub("Metric.Value.", "", .x, fixed=TRUE))
knitr::kable(short) %>%
  kable_styling(full_width = F)
```

```{r, fig.width=12, fig.height=5}
qc_metrics_plots <- qc_metrics
colnames(qc_metrics_plots) <- gsub(".", " ", colnames(qc_metrics_plots), fixed=TRUE)
qc_metrics_plots$`Metric Value` <- gsub("%", "", qc_metrics_plots$`Metric Value`)
qc_metrics_plots$`Metric Value` <- gsub(",", "", qc_metrics_plots$`Metric Value`)
qc_metrics_plots$`Metric Value` <- as.numeric(qc_metrics_plots$`Metric Value`)

a <- c("Estimated number of cells", "Mean reads per cell", "Fraction reads in cells", "Median UMI counts per cell", "Antibody reads usable per cell", "Fraction antibody reads usable")
tmp <- qc_metrics_plots %>% filter(`Metric Name` %in% a)#%>% mutate_all(function(x) as.numeric(as.character(x)))
ggplot(tmp %>% select(ID, `Library Type`, `Metric Name`, `Metric Value`) %>% filter(`Library Type`=='Antibody Capture'), aes(x=ID, y=`Metric Value`, fill=ID)) + geom_col() + facet_wrap(vars(`Metric Name`), scales='free_y', ncol=3) + ggtitle('Antibody Capture')
```

Gene expression summary

```{r}
short <- qc_metrics %>% filter(Category=='Cells', Library.Type=='Gene Expression') %>% select(ID, Metric.Name, Metric.Value)
cnames <- short$Metric.Value
short <- short %>% reshape(idvar="ID",timevar = "Metric.Name", direction='wide') 
short <- rename_with(short, ~ gsub("Metric.Value.", "", .x, fixed=TRUE))
knitr::kable(short) %>%
  kable_styling(full_width = F)#, options = list(searching=FALSE, pageLength=20, lengthMenu=NULL))
```


```{r, fig.width=12, fig.height=5}
a <- c("Estimated number of cells", "Mean reads per cell", "Median genes per cell", "Number of reads", "Confidently mapped to genome", "Fraction reads in cells", "Median UMI counts per cell")
tmp <- qc_metrics_plots %>% filter(`Metric Name` %in% a)
ggplot(tmp %>% select(ID, `Library Type`, `Metric Name`, `Metric Value`) %>% filter(`Library Type`=='Gene Expression'), aes(x=ID, y=`Metric Value`, fill=ID)) + geom_col() + facet_wrap(vars(`Metric Name`), scales='free_y', ncol=3) + ggtitle('Gene Expression')
```

## Detailed

```{r}
short <- qc_metrics %>% filter(Category=='Library', Library.Type=='Antibody Capture')# %>% select(ID, Metric.Name, Metric.Value)
# cnames <- short$Metric.Value
# short <- short %>% reshape(idvar="ID",timevar = "Metric.Name", direction='wide') 
# short <- rename_with(short, ~ gsub("Metric.Value.", "", .x, fixed=TRUE))
knitr::kable(short)#, options = list(searching=FALSE, pageLength=20, lengthMenu=NULL))
```

```{r}
short <- qc_metrics %>% filter(Category=='Library', Library.Type=='Gene Expression')# %>% select(ID, Metric.Name, Metric.Value)
knitr::kable(short)#, options = list(searching=FALSE, pageLength=20, lengthMenu=NULL))
```

***

# Removing ambient RNA

```{r cc_features}
## Adjusting cell cycle scoring gene names if needed 
## Either way, set these two variables
s.features <- cc.genes$s.genes
g2m.features <-  cc.genes$g2m.genes
```

```{r soupx_and_load_data, include=FALSE}
## Avoid rerunning computationally expensive steps if parameters haven't changed
if (!preran){
  if (perform_soupX){
    counts <- mapply(read_counts_soupX, samples$Label,
                     samples$FileID, SIMPLIFY = FALSE)
  } else {
    counts <- lapply(samples$FileID, read_counts)
    names(counts) <- samples$Label
  }
  captures <- mapply(create_and_preprocess_Seurat_object_from_counts,
                     counts, names(counts),
                     MoreArgs = list(min.cells=10,
                                     s.features=cc.genes$s.genes,
                                     g2m.features=cc.genes$g2m.genes,
                                     mito.pattern = "^MT", ribo.pattern="^RP[SL]"))
  if (hashed) {
    captures <- mapply(add_hash_data, captures, counts,
                      MoreArgs = list(hash_table = hash_table))
  }
  
  saveRDS(captures, file='saved_rds/unfiltered_captures.Rds')
  #captures <- mapply(create_hashed_objects, samples$FileID, samples$Label, hash_table=hash_table, mito.pattern = "^MT", ribo.pattern="^RP[SL]")
} else {
  captures <- readRDS('saved_rds/unfiltered_captures.Rds')
}
```

```{r soupX_plots}
#paths <- dir(path='plots', pattern = '*QC1_soupX.png', full.names = TRUE)
### Include graphics doesn't play well with loops, lapply, etc.
knitr::include_graphics('plots/Apr05_HH_5A_QC1_soupX.png')
```

```{r}
knitr::include_graphics('plots/Apr20_HH_5A_QC1_soupX.png')
```

***

# Filtering data

```{r}
## Median absolute deviation outlier detection. Increasing or decreasing the number  
## of MADs will change sensitivity
captures <- lapply(captures, detect_outliers, nmads=4)
```

```{r, fig.width=6, eval=FALSE}
lapply(captures, qc_plots, show_outliers=TRUE)
```

```{r}
## Manually specified thresholds
## Establish default cutoffs
capture_qc_cutoffs <- list()
for (capture in names(captures)) {
  capture_qc_cutoffs[[capture]] <- list(
    percent.mito.max = 10,
    percent.mito.min = 0,
    nCount_RNA.max   = Inf,
    nCount_RNA.min   = 0,
    nFeature_RNA.max = Inf,
    nFeature_RNA.min = 0
  )
}
## Modify cutoffs for individual captures as needed
## capture_qc_cutoffs$`LysM-cre`$percent.mito.max <- 10
```

```{r, results='hide', fig.keep='all', fig.width=10, fig.height=5}
mapply(qc_plots_cutoffs, captures, capture_qc_cutoffs, show_outliers=TRUE)
```

```{r, include=TRUE}
#then apply subsetting criteria
my_subset <- function(capture, cutoffs, by_outlier=FALSE) {
  if (!by_outlier) {
    capture$outlier <- FALSE
  }
  filt <- subset(capture, subset = (
    nFeature_RNA > cutoffs$nFeature_RNA.min & 
    nFeature_RNA < cutoffs$nFeature_RNA.max &
    percent.mito < cutoffs$percent.mito.max & 
    nCount_RNA   > cutoffs$nCount_RNA.min & 
    nCount_RNA   < cutoffs$nCount_RNA.max &
    outlier == FALSE
    )
  )
  print(paste0('Removing ', ncol(capture) - ncol(filt), ' cells of ', ncol(capture), ' from capture ', capture@project.name, ' due to quality filtering cutoffs'))
  return(filt)
}
captures <- mapply(my_subset, captures, capture_qc_cutoffs, by_outlier=TRUE)
```

After filtering

```{r}
lapply(captures, qc_plots)
```

```{r sct_pca, include=FALSE, eval = !report_only}
sct_and_pca <- function(obj){
  obj <- SCTransform(obj, vars.to.regress=c('S.Score', 'G2M.Score'))
  obj <- RunPCA(obj)
  obj
}
captures <- lapply(captures, sct_and_pca)
```

```{r, include=FALSE, eval = !report_only}
lapply(captures, function(x) ElbowPlot(x, ndims=30) + ggtitle(x@project.name))
```

```{r, include=FALSE, eval = !report_only}
## Set your pcs per capture
npcs <- list()
for (capture in names(captures)) {
  npcs[[capture]] <- NA
}
npcs$Apr05_HH_5A <- 10
npcs$Apr20_HH_5A <- 10
```


```{r, include=FALSE, eval = !report_only}
captures <- lapply(captures, function(x){
  FindNeighbors(x, dims=1:npcs[[x@project.name]], verbose=FALSE)
})
captures <- lapply(captures, function(x){
  RunUMAP(x, dims=1:npcs[[x@project.name]], reduction='pca')
})
```

<!-- Removing clusters with low quality cells -->

```{r, eval = !report_only, fig.width=6, fig.height=12, results='hide', fig.keep='all', include=FALSE}
plot_metadata <- function(data){
  #a1<- DimPlot(data, group.by = 'HTO_classification.global')
  p1 <- FeaturePlot(data, reduction='umap', features="nFeature_RNA") + 
    ggtitle("Unique features count")
  p2 <- FeaturePlot(data, reduction='umap', features="nCount_RNA") +
    ggtitle("Total RNA count")
  p3 <- FeaturePlot(data, reduction='umap', features="percent.mito") +
    ggtitle("Mitochondrial feature percentage")
  p4 <-  grid.arrange(p1,p2,p3)
  p4
}
lapply(captures, plot_metadata)
```

```{r, eval = !report_only, results='hide', fig.keep='all', include=FALSE}
## Run this separately for each capture to find a resolution for that capture 
## based on above metadata to isolate clusters to remove.
## this is NOT the final clustering, just for input to doubletFinder
## just choose a reasonable clustering for this processing
res <- c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1)
resplots <- function(res, x){
  x <- FindClusters(x, resolution = res, verbose=FALSE)
  DimPlot(x, reduction='umap', label=TRUE)
}
lapply(res, resplots, x=captures$Apr20_HH_5A)
```

```{r Removing_clusters, eval = !report_only, results='hide', fig.keep='all', include=FALSE}
resolutions <- list()
for (capture in names(captures)) {
  resolutions[[capture]] <- NA
}
resolutions$Apr05_HH_5A <- 0.5
resolutions$Apr20_HH_5A <- 0.2
## if there are problem clusters, specify which to remove based on the 
## cluster ID. e.g. clusters_to_remove$`LysM-cre` <- c(1,13)
clusters_to_remove <- list()
for (capture in names(captures)) {
  clusters_to_remove[[capture]] <- c()
}
captures <- lapply(captures, function(x) {
  FindClusters(x, res = resolutions[[x@project.name]])
})
## Removing the clusters. If the clusters_to_remove is still empty,
## nothing should happen. You will probably not use this often, since 
## the intitial QC filtering should be enough, but this was part of 
## the doubletFinder walkthrough, so it might be relevant one day
captures <- lapply(captures, function(data){
  sub <- clusters_to_remove[[data@project.name]]
  data <- subset(data, subset = seurat_clusters %in% sub, invert = TRUE)
  data@meta.data$seurat_clusters <-
    droplevels(data@meta.data$seurat_clusters)
    return(data)
  })
```

```{r reclustering_after_removal, eval = !report_only, include=FALSE}
## If you DO remove clusters, run this for find neighbors, umap,
## pca, resolution, etc.
if (!is.null(unlist(clusters_to_remove))){
  captures <- lapply(captures, FindNeighbors, dims=1:npcs, verbose=FALSE)
  captures <- lapply(captures, RunUMAP, reduction='pca', dims=1:npcs)
  captures <- mapply(FindClusters, captures, resolution = resolutions)
} 
```

```{r, eval = !report_only, include=FALSE}
lapply(captures, DimPlot)
```

***


# Remove doublets

```{r}
if (hashed){
  captures <- lapply(captures, function(x){
  print(paste0('Removing ', sum(x@meta.data$HTO_classification.global=='Negative'),
               ' negatives from capture ', x@project.name))
  subset(x, subset = `HTO_classification.global` == 'Negative', invert = TRUE)
})
}

```

```{r doubletFinder, include=FALSE}
## this step is long, ~20 mins per capture
if (!preran){
  if (run_doubletFinder){
    ## May need to specify estimated doublet rate if it differs for you
    captures <- mapply(doublet_finder, captures, npcs, hashed=hashed)
    saveRDS(captures, 'saved_rds/doublet_detected_captures.rds')
  }
} else {
  captures <- readRDS('saved_rds/doublet_detected_captures.rds')
}
```

```{r}
filter_doublets <- function(capture, hashed) {
  print(capture@project.name)
  colnames(capture@meta.data)[
    grepl('DF.classifications', colnames(capture@meta.data))] <- 'DF.classifications'
  if (hashed){
    print(table(capture$DF.classifications, capture$HTO_classification.global,
                dnn = c('DoubletFinder', 'Hashing')))
    doub_idx <- capture$HTO_classification.global=='Doublet' | 
      capture$DF.classifications == 'Doublet'
    print(paste0('Removing ', as.character(sum(doub_idx)), ' doublet GEMS'))
    capture <- subset(capture, HTO_classification.global=='Singlet')
  } else {
    doub_idx <- capture$DF.classifications == 'Doublet'
    print(paste0('Removing ', as.character(sum(doub_idx)), ' doublet GEMS'))
  }
  #colnames(x@meta.data)[ncol(x@meta.data)] <- 'DF.classifications'
  capture <- subset(capture, DF.classifications=='Singlet')
  capture@meta.data <- droplevels(capture@meta.data )
  return(capture)
}
captures <- lapply(captures, filter_doublets, hashed = hashed)
```

```{r, include=FALSE}
captures <- lapply(captures, RunPCA)
```

***

# Capture level clusters

```{r, include = FALSE}
lapply(captures, function(x) ElbowPlot(x, ndims=30) + ggtitle(x@project.name))
```

```{r, include=FALSE}
npcs <- list()
for (capture in names(captures)) {
  npcs[[capture]] <- NA
}
npcs$Apr05_HH_5A <- 12
npcs$Apr20_HH_5A <- 10
captures <- lapply(captures, function(x){
  FindNeighbors(x, dims=1:npcs[[x@project.name]], verbose=FALSE)
})
captures <- lapply(captures, function(x){
  RunUMAP(x, dims=1:npcs[[x@project.name]], reduction='pca')
})
```

```{r}
lapply(captures, DimPlot)
```

***

# Integrate samples

Selecting optimal clustering, with tree of how clusters change with different resolutions

```{r, include=FALSE}
if (preran) {
  combined.obj <- readRDS('saved_rds/combined_obj.rds')
} else {
  if (hashed){
    captures <- lapply(captures, function(x){
      x <- AddMetaData(x, metadata = 
                         paste(x$orig.ident, x$HTO_classification, sep = ':'),
                       col.name='ID')
  })
    captures <- unlist(lapply(captures, SplitObject, split.by = 'HTO_classification'))
  } 
  for (n in 1:length(captures)){
    DefaultAssay(captures[[n]]) <- 'SCT'
  }
  ftrs <- SelectIntegrationFeatures(captures)
  captures <- PrepSCTIntegration(captures, anchor.features = ftrs)
  anchors <- FindIntegrationAnchors(captures, anchor.features = ftrs,
                                    normalization.method = 'SCT')
  
  ## https://github.com/satijalab/seurat/issues/3930
  if (min(unlist(lapply(captures, ncol))) < 50){
    message('Waring: your smallest split object has fewer than 50 cells. 
            Make sure this is correct before moving forward,
            it may have impacts on integration')
  }
  
  combined.obj <- IntegrateData(anchors, normalization.method = 'SCT',
                                k.weight = min(unlist(lapply(captures, ncol)), 100))
  saveRDS(combined.obj, 'saved_rds/combined_obj.rds')
}
```

```{r, include=FALSE}
combined.obj <- RunPCA(combined.obj)
ElbowPlot(combined.obj, ndims = 30)
```

```{r, include=FALSE}
npcs = 10
combined.obj <- FindNeighbors(combined.obj, dims=1:npcs, verbose=FALSE)
combined.obj <- RunUMAP(combined.obj, reduction='pca', dims=1:npcs)
```

<!-- ## Clustering tree -->

```{r, fig.width=12, fig.height=6,}
testclustree <- FindClusters(combined.obj, resolution = c(0.4, .45,.5, .55, .6, .65, .7), verbose=FALSE)
clustree(testclustree) +
    guides(edge_colour = FALSE) + theme(legend.position = "top")
rm(testclustree)
```


```{r, results='hide', fig.keep='none'}
res <- c(0.6, 0.65,0.7)
resplots <- function(res, x){
  x <- FindClusters(x, resolution = res, verbose=FALSE)
  DimPlot(x, reduction='umap', label=TRUE,
          group.by = paste0("integrated_snn_res.", res))
}
lapply(res, resplots, x=combined.obj)
```

```{r}
res = 0.65
print(paste0('Selected resolution of ', res))
combined.obj <- FindClusters(combined.obj, resolution = res, verbose=FALSE)
#combined.obj <- RunTSNE(combined.obj)
DimPlot(combined.obj, reduction = 'umap', label=TRUE)
```

# Final integrated dataset

```{r, fig.width = 8, fig.height = 8}
FeaturePlot(combined.obj, reduction='umap', features=c("nCount_RNA", 'nFeature_RNA', 'percent.mito', 'percent.ribo'), ncol = 2)
```

```{r, fig.width=10}
DimPlot(combined.obj, split.by = 'orig.ident', label=TRUE)
```

```{r, fig.width=12, fig.height=8}
if (hashed) {
  DimPlot(combined.obj, split.by = 'ID', ncol = 5, group.by='HTO_classification')
}
```

How much of each capture is in each cluster

```{r}
if (hashed){
  tmp <- as.data.frame.matrix(table(combined.obj$seurat_clusters,
                                    combined.obj$ID))
  knitr::kable(tmp, caption = 'Number of cells')
  tmp <- tmp %>% mutate(across(.cols= everything(), ~ 100*.x / sum(.x))) #, .names = "{.col}_percent"
  knitr::kable(tmp, caption = 'Percentage of cells from capture', digits = 1)
} else {
  tmp <- as.data.frame.matrix(table(combined.obj$seurat_clusters,
                                    combined.obj$orig.ident))
knitr::kable(tmp, caption = 'Number of cells')
tmp <- tmp %>% mutate(across(.cols= everything(), ~ 100*.x / sum(.x))) #, .names = "{.col}_percent"
knitr::kable(tmp, caption = 'Percentage of cells from capture', digits = 1)
}

```


```{r}
if (!preran){
  saveRDS(combined.obj, file='saved_rds/combined_obj_final.Rds')
}
```